<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>安卓麦克风与语音识别测试</title>
    <style>
        /*
         * CSS 样式部分：定义网页的外观和布局。
         * 这些样式确保网页在不同大小的屏幕（包括安卓触屏设备）上都能良好显示。
         */

        /* 全局样式：应用于整个页面的基本设置 */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; /* 设置字体，提供清晰的文本显示 */
            margin: 0; /* 移除页面外边距 */
            padding: 20px; /* 页面内边距，让内容不紧贴边缘 */
            background-color: #f4f7f6; /* 页面背景色，柔和的灰色 */
            color: #333; /* 默认文本颜色 */
            display: flex; /* 使用Flexbox布局，方便内容垂直居中 */
            flex-direction: column; /* Flexbox方向为列，使内容垂直堆叠 */
            align-items: center; /* 水平居中Flexbox项目 */
            min-height: 100vh; /* 最小高度为视口高度，确保内容少时也能撑满屏幕 */
            box-sizing: border-box; /* 盒模型设置为边框盒，padding和border不增加元素总宽度/高度 */
        }

        /* 容器样式：用于包裹主要内容的矩形区域 */
        .container {
            background-color: #ffffff; /* 容器背景色为白色 */
            padding: 30px; /* 容器内边距 */
            border-radius: 12px; /* 圆角边框，使界面更柔和 */
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.08); /* 阴影效果，增加立体感 */
            width: 100%; /* 宽度占满父容器 */
            max-width: 600px; /* 最大宽度限制，防止在大屏幕上过宽 */
            margin-bottom: 20px; /* 容器底部外边距，与其他容器分隔 */
            text-align: center; /* 容器内文本居中对齐 */
        }

        /* 标题样式 */
        h1 {
            color: #2c3e50; /* 标题颜色，深蓝色 */
            margin-bottom: 25px; /* 标题底部外边距 */
            font-size: 1.8em; /* 标题字体大小 */
        }

        /* 按钮样式 */
        button {
            background-color: #4CAF50; /* 按钮背景色，绿色 */
            color: white; /* 按钮文本颜色 */
            padding: 12px 25px; /* 按钮内边距，增加点击区域 */
            border: none; /* 无边框 */
            border-radius: 8px; /* 圆角按钮 */
            cursor: pointer; /* 鼠标悬停时显示手型光标 */
            font-size: 1.1em; /* 按钮字体大小 */
            transition: background-color 0.3s ease, transform 0.2s ease; /* 过渡效果，使交互更平滑 */
            margin: 10px; /* 按钮外边距 */
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1); /* 按钮阴影 */
        }

        /* 按钮悬停状态 */
        button:hover {
            background-color: #45a049; /* 悬停时颜色变深 */
            transform: translateY(-2px); /* 向上轻微移动，增加交互感 */
        }

        /* 按钮点击状态 */
        button:active {
            background-color: #3e8e41; /* 点击时颜色更深 */
            transform: translateY(0); /* 恢复原始位置 */
        }

        /* 按钮禁用状态 */
        button:disabled {
            background-color: #cccccc; /* 禁用时背景色变灰 */
            cursor: not-allowed; /* 鼠标显示禁止符号 */
            box-shadow: none; /* 禁用时移除阴影 */
        }

        /* 状态、结果和日志显示区域的通用样式 */
        .status-section, .results-section, .log-section, .audio-info-section {
            margin-top: 25px; /* 顶部外边距 */
            padding: 20px; /* 内边距 */
            background-color: #e8f5e9; /* 淡绿色背景 */
            border-radius: 10px; /* 圆角 */
            border: 1px solid #d4edda; /* 边框 */
            text-align: left; /* 文本左对齐 */
        }

        /* 各个区域的标题样式 */
        .status-section h2, .results-section h2, .log-section h2, .audio-info-section h2 {
            color: #2e7d32; /* 标题颜色，深绿色 */
            margin-top: 0; /* 移除顶部外边距 */
            margin-bottom: 15px; /* 底部外边距 */
            font-size: 1.4em; /* 字体大小 */
        }

        /* 状态消息文本样式 */
        #status-message {
            font-size: 1.1em; /* 字体大小 */
            color: #333; /* 文本颜色 */
            line-height: 1.6; /* 行高，增加可读性 */
        }

        /* 识别结果/录音信息显示区域样式 */
        #recognition-results {
            white-space: pre-wrap; /* 保留空白符和换行符，确保格式正确 */
            word-break: break-word; /* 允许长单词在必要时换行 */
            min-height: 80px; /* 最小高度 */
            background-color: #f9f9f9; /* 背景色 */
            padding: 15px; /* 内边距 */
            border-radius: 8px; /* 圆角 */
            border: 1px solid #eee; /* 边框 */
            font-size: 1.1em; /* 字体大小 */
            color: #555; /* 文本颜色 */
            overflow-y: auto; /* 内容溢出时显示垂直滚动条 */
            max-height: 200px; /* 最大高度限制 */
        }

        /* 日志输出区域样式 */
        #log-output {
            white-space: pre-wrap; /* 保留空白符和换行符 */
            word-break: break-word; /* 允许长单词换行 */
            min-height: 100px; /* 最小高度 */
            max-height: 300px; /* 最大高度限制，防止日志过多撑满页面 */
            background-color: #f0f0f0; /* 略深的背景色，与内容区域区分 */
            padding: 15px; /* 内边距 */
            border-radius: 8px; /* 圆角 */
            border: 1px solid #ddd; /* 边框 */
            font-size: 0.9em; /* 字体略小，适合显示日志 */
            color: #444; /* 文本颜色 */
            overflow-y: auto; /* 内容溢出时显示垂直滚动条 */
            font-family: 'Courier New', Courier, monospace; /* 等宽字体，方便查看日志 */
        }

        /* 错误状态文本颜色 */
        .error {
            color: #d32f2f; /* 红色 */
            font-weight: bold; /* 加粗 */
        }

        /* 成功状态文本颜色 */
        .success {
            color: #388e3c; /* 绿色 */
            font-weight: bold; /* 加粗 */
        }

        /* 日志中错误信息的颜色 */
        .log-error {
            color: #d32f2f;
        }

        /* 日志中警告信息的颜色 */
        .log-warn {
            color: #f57f17; /* 橙色 */
        }

        /* 日志中普通信息的颜色 */
        .log-info {
            color: #1976d2; /* 蓝色 */
        }

        /* 媒体查询：针对小屏幕设备（如手机）的适配 */
        @media (max-width: 600px) {
            .container {
                padding: 20px; /* 小屏幕下容器内边距减小 */
            }
            button {
                width: 100%; /* 按钮宽度占满父容器 */
                margin: 8px 0; /* 按钮垂直外边距 */
            }
            h1 {
                font-size: 1.5em; /* 小屏幕下标题字体减小 */
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>安卓麦克风与语音识别测试</h1> <p>点击下方按钮，测试您的安卓设备浏览器是否支持麦克风权限和语音识别功能。</p>

        <div class="controls">
            <button id="requestPermissionButton">请求麦克风权限</button>
            <button id="startRecognitionAndRecordingButton" disabled>开始语音识别并录音</button>
            <button id="stopRecognitionAndRecordingButton" disabled>停止语音识别并录音</button>
        </div>

        <div class="status-section">
            <h2>当前状态</h2>
            <p id="status-message">等待操作...</p>
        </div>
    </div>

    <div class="container results-section">
        <h2>识别结果</h2>
        <pre id="recognition-results">暂无识别结果。</pre>
    </div>

    <div class="container audio-info-section">
        <h2>录音信息</h2>
        <pre id="audio-stream-status">等待开始...</pre>
        <pre id="audio-track-info">麦克风轨道: 未连接</pre>
    </div>

    <div class="container log-section">
        <h2>调试日志</h2>
        <pre id="log-output">日志将显示在此处...</pre>
        <button id="clearLogButton">清空日志</button>
    </div>

    <script>
        /*
         * JavaScript 核心功能模块：
         * 整个JavaScript代码被封装在一个“立即执行函数表达式 (IIFE)”中。
         * 这样做的好处是：
         * 1. 避免全局变量污染：所有变量都在这个函数内部，不会影响到其他脚本。
         * 2. 模块化：代码被组织成独立的逻辑块，便于管理和维护。
         */
        const SpeechRecognitionAndRecordingModule = (function() {
            // 私有变量：这些变量只能在当前模块内部访问和修改。
            let recognition = null; // 用于存储Web Speech API的语音识别对象
            let mediaStream = null; // 用于存储从麦克风获取的音频流对象
            let isRecognizingAndRecording = false; // 标志，表示当前是否正在识别和录音
            let finalTranscript = ''; // 存储最终的语音识别结果文本

            // 获取DOM元素：提前获取页面上需要操作的HTML元素，避免重复查找。
            const statusMessageElement = document.getElementById('status-message'); // 用于显示当前操作状态的段落
            const recognitionResultsElement = document.getElementById('recognition-results'); // 用于显示语音识别结果的pre标签
            const audioStreamStatusElement = document.getElementById('audio-stream-status'); // 用于显示音频流状态的pre标签
            const audioTrackInfoElement = document.getElementById('audio-track-info'); // 用于显示音频轨道信息的pre标签
            // 按钮ID更新，以反映其双重功能（识别和录音）
            const startRecognitionAndRecordingButton = document.getElementById('startRecognitionAndRecordingButton'); // “开始语音识别并录音”按钮
            const stopRecognitionAndRecordingButton = document.getElementById('stopRecognitionAndRecordingButton'); // “停止语音识别并录音”按钮
            const requestPermissionButton = document.getElementById('requestPermissionButton'); // “请求麦克风权限”按钮
            const logOutputElement = document.getElementById('log-output'); // 日志输出区域
            const clearLogButton = document.getElementById('clearLogButton'); // 清空日志按钮

            /**
             * @module Logger
             * @description 日志模块：负责将调试信息输出到网页和浏览器控制台。
             * 这样即使没有连接电脑，也能直接在手机上看到运行日志。
             */
            const Logger = (function() {
                /**
                 * logToPage 函数：将日志消息添加到网页上的日志输出区域。
                 * @param {string} message 要记录的日志消息。
                 * @param {string} type 日志类型（'info'：普通信息，'warn'：警告，'error'：错误）。
                 */
                function logToPage(message, type = 'info') {
                    const timestamp = new Date().toLocaleTimeString(); // 获取当前时间，用于日志时间戳
                    const logEntry = document.createElement('div'); // 创建一个新的div元素来承载日志条目
                    logEntry.textContent = `[${timestamp}] ${message}`; // 设置日志文本，包含时间戳
                    logEntry.className = `log-${type}`; // 根据日志类型添加CSS类，用于不同颜色显示

                    // 将新的日志条目添加到日志区域的顶部，让最新日志最先显示。
                    if (logOutputElement.firstChild) {
                        logOutputElement.insertBefore(logEntry, logOutputElement.firstChild);
                    } else {
                        logOutputElement.appendChild(logEntry);
                    }

                    // 控制日志条目数量，防止日志过多导致页面卡顿或内存溢出。
                    const maxLogEntries = 100; // 最多保留100条日志
                    while (logOutputElement.children.length > maxLogEntries) {
                        logOutputElement.removeChild(logOutputElement.lastChild); // 移除最旧的日志
                    }

                    // 同时将日志输出到浏览器控制台，方便更专业的调试。
                    if (type === 'error') {
                        console.error(message);
                    } else if (type === 'warn') {
                        console.warn(message);
                    } else {
                        console.log(message);
                    }
                }

                /**
                 * clearLogs 函数：清空网页上的所有日志。
                 */
                function clearLogs() {
                    logOutputElement.innerHTML = '日志已清空。'; // 清空内容并显示提示
                    console.log('[Logger] Logs cleared from page.'); // 控制台也记录清空操作
                }

                // 返回一个包含公共方法的对象，供其他模块调用。
                return {
                    info: (msg) => logToPage(msg, 'info'), // 普通信息日志
                    warn: (msg) => logToPage(msg, 'warn'), // 警告信息日志
                    // 错误信息日志，可以接收一个错误对象，用于打印更详细的错误信息（如错误名称、消息、堆栈）。
                    error: (msg, errorDetail = null) => {
                        let fullMsg = msg;
                        if (errorDetail) {
                            if (typeof errorDetail === 'string') {
                                fullMsg += ` 错误类型: ${errorDetail}`; // 如果是字符串，直接作为错误类型
                            } else if (errorDetail instanceof Error) {
                                fullMsg += ` 错误: ${errorDetail.name || '未知错误'} - ${errorDetail.message || '无消息'}`;
                                if (errorDetail.stack) {
                                    fullMsg += `\n堆栈: ${errorDetail.stack}`; // 包含错误堆栈
                                }
                            } else if (typeof errorDetail === 'object' && 'error' in errorDetail) {
                                // 专门处理 SpeechRecognitionErrorEvent 这种包含 'error' 属性的对象
                                fullMsg += ` 错误类型: ${errorDetail.error}`;
                                if (errorDetail.message) {
                                    fullMsg += ` 消息: ${errorDetail.message}`;
                                }
                            } else {
                                fullMsg += ` 详情: ${JSON.stringify(errorDetail)}`; // 其他未知类型的错误详情
                            }
                        }
                        logToPage(fullMsg, 'error');
                    },
                    clear: clearLogs // 清空日志方法
                };
            })();

            /**
             * @module Permissions
             * @description 权限模块：处理麦克风权限的请求和检查。
             */
            const Permissions = (function() {
                /**
                 * requestMicrophonePermission 函数：请求麦克风权限。
                 * @returns {Promise<boolean>} 返回一个Promise，如果成功获取权限则解析为 true，否则解析为 false。
                 */
                async function requestMicrophonePermission() {
                    Logger.info('[权限] 正在尝试请求麦克风权限...'); // 记录日志
                    statusMessageElement.textContent = '正在请求麦克风权限...'; // 更新页面状态
                    try {
                        // navigator.mediaDevices.getUserMedia 是Web API，用于请求用户访问媒体输入设备（如麦克风、摄像头）。
                        // { audio: true } 表示我们只需要音频输入。
                        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                        // 如果成功获取到流，说明权限已授予。
                        // 此时，我们立即停止并释放麦克风，因为这个函数只是为了“检查权限”，而不是开始录音。
                        stream.getTracks().forEach(track => track.stop());
                        Logger.info('[权限] 麦克风权限已成功授予。'); // 记录成功日志
                        statusMessageElement.textContent = '麦克风权限已授予。您可以开始语音识别和录音了。'; // 更新页面状态
                        statusMessageElement.className = 'success'; // 添加成功样式
                        startRecognitionAndRecordingButton.disabled = false; // 启用“开始语音识别并录音”按钮
                        return true; // 返回成功
                    } catch (error) {
                        // 如果获取权限失败，会捕获到错误。
                        Logger.error('[权限] 获取麦克风权限失败:', error); // 记录错误日志，包含错误详情
                        let errorMessage = '获取麦克风权限失败。请检查您的设备设置，确保浏览器有权访问麦克风。';
                        if (error.name === 'NotAllowedError') {
                            // NotAllowedError 表示用户拒绝了权限请求，或者权限已被系统禁用。
                            errorMessage = '用户拒绝了麦克风权限请求或权限已被禁用。';
                        } else if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {
                            // NotNotFoundError/DevicesNotFoundError 表示未找到麦克风设备。
                            errorMessage = '未找到麦克风设备。';
                        } else if (error.name === 'AbortError') {
                            // AbortError 表示权限请求被中止。
                            errorMessage = '权限请求被中止。';
                        } else if (error.name === 'SecurityError') {
                            // SecurityError 表示安全错误，通常是因为页面没有通过HTTPS提供。
                            errorMessage = '安全错误：可能需要在HTTPS环境下运行。';
                        }
                        statusMessageElement.textContent = errorMessage; // 更新页面状态为错误信息
                        statusMessageElement.className = 'error'; // 添加错误样式
                        startRecognitionAndRecordingButton.disabled = true; // 禁用“开始语音识别并录音”按钮
                        return false; // 返回失败
                    }
                }

                // 返回公共方法，供外部使用。
                return {
                    requestMicrophonePermission
                };
            })();

            /**
             * @module SpeechAndAudioHandler
             * @description 语音识别与录音处理模块：结合了麦克风音频流的获取和Web Speech API的语音识别功能。
             */
            const SpeechAndAudioHandler = (function() {
                /**
                 * updateAudioInfo 函数：更新页面上显示的音频流和轨道信息。
                 */
                function updateAudioInfo() {
                    if (mediaStream && mediaStream.active) {
                        // 如果媒体流存在且处于激活状态
                        audioStreamStatusElement.textContent = `音频流状态: 激活中 (ID: ${mediaStream.id})`;
                        const audioTracks = mediaStream.getAudioTracks();
                        if (audioTracks.length > 0) {
                            const track = audioTracks[0];
                            audioTrackInfoElement.textContent = `麦克风轨道: ${track.label} (ID: ${track.id}, 状态: ${track.readyState}, 静音: ${track.muted})`;
                        } else {
                            audioTrackInfoElement.textContent = '麦克风轨道: 未找到音频轨道。';
                        }
                    } else {
                        // 如果媒体流不激活或不存在
                        audioStreamStatusElement.textContent = '音频流状态: 未激活';
                        audioTrackInfoElement.textContent = '麦克风轨道: 未连接';
                    }
                }

                /**
                 * initializeRecognition 函数：初始化Web Speech API的语音识别对象。
                 * 这一步在页面加载时就完成，确保识别器对象准备就绪。
                 */
                function initializeRecognition() {
                    Logger.info('[语音识别] 正在初始化语音识别服务...'); // 记录日志
                    // 检查浏览器是否支持Web Speech API
                    if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
                        Logger.error('[语音识别] 抱歉，您的浏览器不支持Web Speech API。'); // 记录错误
                        statusMessageElement.textContent = '抱歉，您的浏览器不支持语音识别功能。请尝试使用支持Web Speech API的最新版Chrome浏览器。';
                        statusMessageElement.className = 'error';
                        startRecognitionAndRecordingButton.disabled = true;
                        stopRecognitionAndRecordingButton.disabled = true;
                        return;
                    }

                    // 优先使用 webkitSpeechRecognition (Chrome等浏览器支持)
                    recognition = new (window.SpeechRecognition || window.webkitSpeechRecognition)();
                    Logger.info('[语音识别] SpeechRecognition 对象已创建。'); // 记录创建成功

                    // 设置语音识别器的属性
                    recognition.continuous = true; // 持续识别，直到调用 stop()
                    recognition.interimResults = true; // 返回临时结果，以便实时显示
                    recognition.lang = 'zh-CN'; // 设置识别语言为中文（中国）
                    Logger.info('[语音识别] 识别属性已设置: 持续=true, 临时结果=true, 语言=zh-CN。');

                    // 语音识别器事件监听器：这些函数在识别过程的不同阶段被触发
                    recognition.onstart = function() {
                        isRecognizingAndRecording = true; // 标志识别正在进行
                        Logger.info('[语音识别] 事件: onstart - 语音识别已启动。');
                        statusMessageElement.textContent = '语音识别已启动，请开始讲话...';
                        statusMessageElement.className = ''; // 清除状态样式
                        startRecognitionAndRecordingButton.disabled = true; // 禁用开始按钮
                        stopRecognitionAndRecordingButton.disabled = false; // 启用停止按钮
                        finalTranscript = ''; // 重置最终识别结果
                        recognitionResultsElement.textContent = '正在倾听...'; // 显示提示
                    };

                    recognition.onresult = function(event) {
                        let interimTranscript = ''; // 临时识别结果
                        Logger.info('[语音识别] 事件: onresult - 收到识别结果。');
                        // 遍历所有识别结果
                        for (let i = event.resultIndex; i < event.results.length; ++i) {
                            const transcript = event.results[i][0].transcript; // 获取识别到的文本
                            if (event.results[i].isFinal) {
                                finalTranscript += transcript; // 如果是最终结果，累加到最终文本
                                Logger.info(`[语音识别] 最终结果部分: "${transcript}"`);
                            } else {
                                interimTranscript += transcript; // 如果是临时结果，累加到临时文本
                                Logger.info(`[语音识别] 临时结果部分: "${transcript}"`);
                            }
                        }
                        // 在页面上显示临时结果和最终结果
                        recognitionResultsElement.textContent = `最终结果: ${finalTranscript}\n临时结果: ${interimTranscript}`;
                    };

                    recognition.onerror = function(event) {
                        isRecognizingAndRecording = false; // 识别停止
                        // 将整个事件对象传递给 Logger.error，以便记录更详细的错误信息
                        Logger.error('[语音识别] 事件: onerror - 语音识别发生错误!', event);
                        let errorMessage = `语音识别错误：${event.error}`; // event.error 是错误类型字符串
                        if (event.error === 'not-allowed') {
                            errorMessage = '语音识别被拒绝。请确保已授权麦克风权限，且未被其他应用占用。';
                        } else if (event.error === 'no-speech') {
                            errorMessage = '未检测到语音。请确保麦克风正常工作并重新尝试。';
                        } else if (event.error === 'network') {
                            errorMessage = '网络错误，请检查您的网络连接。';
                        } else if (event.error === 'aborted') {
                            errorMessage = '语音识别被中止。这可能是由于网络问题、麦克风被占用或浏览器内部错误。';
                        } else if (event.error === 'audio-capture') {
                            errorMessage = '无法捕获音频。请检查麦克风连接或驱动。';
                        } else if (event.error === 'service-not-allowed') {
                            errorMessage = '语音识别服务不允许。可能需要在HTTPS环境下运行。';
                        }
                        statusMessageElement.textContent = errorMessage; // 更新页面状态为错误信息
                        statusMessageElement.className = 'error'; // 添加错误样式
                        startRecognitionAndRecordingButton.disabled = false; // 启用开始按钮
                        stopRecognitionAndRecordingButton.disabled = true; // 禁用停止按钮
                        updateAudioInfo(); // 更新录音信息
                    };

                    recognition.onend = function() {
                        // 识别结束（正常停止或因错误/超时等）
                        isRecognizingAndRecording = false; // 识别停止
                        Logger.info('[语音识别] 事件: onend - 语音识别已结束。');
                        statusMessageElement.textContent = '语音识别已停止。';
                        statusMessageElement.className = '';
                        startRecognitionAndRecordingButton.disabled = false; // 启用开始按钮
                        stopRecognitionAndRecordingButton.disabled = true; // 禁用停止按钮
                        // 确保最终结果被显示
                        if (finalTranscript) {
                            recognitionResultsElement.textContent = `最终识别结果:\n${finalTranscript}`;
                        } else {
                            recognitionResultsElement.textContent = '暂无识别结果。';
                        }
                        // 确保停止麦克风流，释放麦克风资源
                        if (mediaStream) {
                            mediaStream.getTracks().forEach(track => track.stop());
                            mediaStream = null;
                            Logger.info('[语音识别] 麦克风流已通过 onend 事件停止。');
                        }
                        updateAudioInfo(); // 更新录音信息
                    };

                    // 以下是Web Speech API的一些额外事件，用于更细致的调试：
                    recognition.onspeechstart = function() {
                        Logger.info('[语音识别] 事件: onspeechstart - 检测到语音输入。');
                    };

                    recognition.onspeechend = function() {
                        Logger.info('[语音识别] 事件: onspeechend - 语音输入已结束。');
                    };

                    recognition.onaudiostart = function() {
                        Logger.info('[语音识别] 事件: onaudiostart - 音频捕获已开始。');
                    };

                    recognition.onaudioend = function() {
                        Logger.info('[语音识别] 事件: onaudioend - 音频捕获已结束。');
                    };
                }

                /**
                 * startRecognitionAndRecording 函数：开始语音识别并录音。
                 * 1. 首先获取麦克风音频流。
                 * 2. 然后启动语音识别服务。
                 */
                async function startRecognitionAndRecording() {
                    Logger.info('[主控] 正在尝试开始语音识别和录音...'); // 记录日志
                    if (isRecognizingAndRecording) {
                        Logger.warn('[主控] 语音识别和录音已在进行中。'); // 如果已在进行中，发出警告
                        statusMessageElement.textContent = '语音识别和录音正在进行中...';
                        return;
                    }

                    statusMessageElement.textContent = '正在启动麦克风和识别服务...'; // 更新页面状态
                    recognitionResultsElement.textContent = '正在初始化识别...'; // 清空并提示识别区域

                    try {
                        // 1. 获取麦克风音频流 (录音部分)
                        // navigator.mediaDevices.getUserMedia 返回一个Promise，成功时提供MediaStream对象。
                        // 这是获取麦克风输入的关键步骤。
                        mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                        Logger.info('[主控] 麦克风音频流已成功获取。');
                        updateAudioInfo(); // 立即更新页面上的录音信息

                        // 为媒体流添加事件监听器，以便在流状态改变时记录日志。
                        // 这有助于追踪麦克风是否意外停止。
                        mediaStream.oninactive = () => {
                            Logger.info('[录音] 音频流已停止 (oninactive 事件)。');
                            // 如果流不活跃，尝试停止所有识别和录音进程
                            stopRecognitionAndRecording();
                        };
                        mediaStream.onended = () => {
                            Logger.info('[录音] 音频流已结束 (onended 事件)。');
                            // 如果流结束，尝试停止所有识别和录音进程
                            stopRecognitionAndRecording();
                        };
                        mediaStream.onaddtrack = (event) => {
                            Logger.info(`[录音] 新增音频轨道: ${event.track.label}`);
                            updateAudioInfo();
                        };
                        mediaStream.onremovetrack = (event) => {
                            Logger.info(`[录音] 移除音频轨道: ${event.track.label}`);
                            updateAudioInfo();
                        };


                        // 2. 启动语音识别 (识别部分)
                        // 如果识别器尚未初始化，则先初始化它。
                        if (!recognition) {
                            initializeRecognition();
                        }
                        recognition.start(); // 调用 Web Speech API 的 start 方法开始识别

                        // onstart 事件会负责更新 isRecognizingAndRecording 状态和按钮。
                        // 这里的 try-catch 主要捕获 getUserMedia 的错误。
                    } catch (error) {
                        // 捕获获取音频流或启动识别过程中可能发生的错误。
                        Logger.error('[主控] 启动语音识别和录音失败:', error); // 记录详细错误日志
                        let errorMessage = '启动失败。请确保麦克风权限已授予且麦克风未被占用。';
                        if (error.name === 'NotAllowedError') {
                            errorMessage = '用户拒绝了麦克风权限或权限已被禁用。';
                        } else if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {
                            errorMessage = '未找到麦克风设备。';
                        } else if (error.name === 'AbortError') {
                            errorMessage = '操作被中止。这可能是由于网络问题、麦克风被占用或浏览器内部错误。';
                        } else if (error.name === 'SecurityError') {
                            errorMessage = '安全错误：可能需要在HTTPS环境下运行。';
                        } else if (error.name === 'NotReadableError') {
                            errorMessage = '麦克风无法读取。可能被其他应用占用或硬件故障。';
                        }
                        statusMessageElement.textContent = errorMessage; // 更新页面状态为错误信息
                        statusMessageElement.className = 'error'; // 添加错误样式
                        startRecognitionAndRecordingButton.disabled = false; // 启用开始按钮
                        stopRecognitionAndRecordingButton.disabled = true; // 禁用停止按钮
                        updateAudioInfo(); // 更新录音信息
                    }
                }

                /**
                 * stopRecognitionAndRecording 函数：停止语音识别并释放麦克风。
                 */
                function stopRecognitionAndRecording() {
                    Logger.info('[主控] 正在尝试停止语音识别和录音...'); // 记录日志
                    if (!isRecognizingAndRecording) {
                        Logger.warn('[主控] 语音识别和录音未启动或已停止。'); // 如果未在进行中，发出警告
                        statusMessageElement.textContent = '语音识别和录音未启动或已停止。';
                        return;
                    }

                    // 1. 停止语音识别服务
                    // 调用 Web Speech API 的 stop 方法来终止识别过程。
                    if (recognition) {
                        recognition.stop();
                        Logger.info('[主控] recognition.stop() 已调用。');
                    }

                    // 2. 停止麦克风音频流并释放麦克风资源
                    // 遍历媒体流中的所有轨道（包括音频和视频，这里只有音频），并停止它们。
                    // track.stop() 是释放麦克风的关键操作。
                    if (mediaStream) {
                        mediaStream.getTracks().forEach(track => {
                            track.stop();
                            Logger.info(`[主控] 停止麦克风轨道: ${track.label} (ID: ${track.id})`);
                        });
                        mediaStream = null; // 清空媒体流变量
                    }

                    isRecognizingAndRecording = false; // 更新状态为停止
                    Logger.info('[主控] 语音识别和麦克风已停止。'); // 记录成功日志
                    statusMessageElement.textContent = '语音识别和录音已停止。'; // 更新页面状态
                    statusMessageElement.className = ''; // 清除状态样式
                    startRecognitionAndRecordingButton.disabled = false; // 启用开始按钮
                    stopRecognitionAndRecordingButton.disabled = true; // 禁用停止按钮
                    updateAudioInfo(); // 更新录音信息
                }

                // 返回公共方法，供外部使用。
                return {
                    initializeRecognition, // 在模块加载时初始化识别器
                    start: startRecognitionAndRecording, // 启动识别和录音
                    stop: stopRecognitionAndRecording // 停止识别和录音
                };
            })();

            /**
             * @module EventHandlers
             * @description 事件处理模块：负责为页面上的按钮添加事件监听器。
             */
            const EventHandlers = (function() {
                /**
                 * init 函数：初始化所有事件监听器。
                 */
                function init() {
                    Logger.info('[事件处理] 正在初始化所有事件监听器。'); // 记录日志
                    // 为“请求麦克风权限”按钮添加点击事件，调用 Permissions 模块的相应方法。
                    requestPermissionButton.addEventListener('click', Permissions.requestMicrophonePermission);
                    // 为“开始语音识别并录音”按钮添加点击事件，调用 SpeechAndAudioHandler 模块的相应方法。
                    startRecognitionAndRecordingButton.addEventListener('click', SpeechAndAudioHandler.start);
                    // 为“停止语音识别并录音”按钮添加点击事件，调用 SpeechAndAudioHandler 模块的相应方法。
                    stopRecognitionAndRecordingButton.addEventListener('click', SpeechAndAudioHandler.stop);
                    // 为“清空日志”按钮添加点击事件，调用 Logger 模块的相应方法。
                    clearLogButton.addEventListener('click', Logger.clear);

                    // 在页面加载时初始化语音识别对象，但不会立即开始识别。
                    // 这确保 recognition 对象在需要时已经准备就绪。
                    SpeechAndAudioHandler.initializeRecognition();
                }

                // 返回公共方法。
                return {
                    init
                };
            })();

            // 公共接口：暴露给外部调用的模块初始化方法。
            // 当页面加载完成后，会调用 SpeechRecognitionAndRecordingModule.init() 来启动整个应用。
            return {
                init: EventHandlers.init // 初始化所有事件处理器
            };

        })(); // 立即执行函数表达式 (IIFE) 结束

        // DOMContentLoaded 事件监听器：
        // 确保在HTML文档的DOM（文档对象模型）完全加载和解析后才执行JavaScript代码。
        // 这样可以避免在HTML元素尚未创建时就尝试操作它们而导致的错误。
        document.addEventListener('DOMContentLoaded', SpeechRecognitionAndRecordingModule.init);
    </script>
</body>
</html>
